# R Graphics with ggplot2
# Amanda Gentry and Mikhail Dozmorov, Ph.D.
# Materials borrowed from Clay Ford, UVa StatLab

# Helpful RStudio commands ------------------------------------------------

# Description       Windows & Linux       Mac 
# ----------------------------------------------------------------
# Run current line  Ctrl+Enter            Command+Enter
# Previous plot     Ctrl+Shift+PageUp     Command+Shift+PageUp 
# Next plot 	      Ctrl+Shift+PageDown 	Command+Shift+PageDown 


# Packages ----------------------------------------------------------------

# only submit these lines if you don't already have these packages installed. 
install.packages("ggplot2")
install.packages("gridExtra") # to fit multiple plots in a window


# We'll also use the scales package; when you install ggplot2, the scales
# package is also installed

library(ggplot2)
library(gridExtra)
library(scales)

# Data --------------------------------------------------------------------

# Albemarle County real estate data
# Addresses with City identified as "Charlottesville"
# Downloaded from Office of Geographic Data Services, 15-Sept-2015

# Primary Card Level Data - this file includes data such as year built, 
# finished square footage, number of rooms, and condition.
# http://www.albemarle.org/gds/gisdata/CAMA/CAMA_CardLevelData_TXT.zip

# merged with...

# Real Estate Information - Parcel Level Data.  This file contains information
# about the parcel itself such as assessed value
# http://www.albemarle.org/gds/gisdata/CAMA/CAMA_ParcelInfo_TXT.zip

# download and read in:
url1 <- "http://people.virginia.edu/~jcf2d/workshops/ggplot2/cville_real_estate.csv"
homes <- read.csv(url1)
class(homes) # data.frame

str(homes)

# One Variable ------------------------------------------------------------

# The histogram helps us see how a continous variable is distributed
ggplot(homes, aes(x=FinSqFt)) + geom_histogram()

# note the message regarding "stat_bin".
# Recall "stat_bin" is the stat for geom_histogram.

# Says the documentation: "You should always override this value, exploring
# multiple widths to find the best to illustrate the stories in your data."

# Try a new binwidth
ggplot(homes, aes(x=FinSqFt)) + geom_histogram(binwidth=50)
# try some others!

# what if we want a "True" Histogram with density instead of count?
ggplot(homes, aes(x=FinSqFt, y=..density..)) + 
  geom_histogram(binwidth=250)

# ..density.. is a variable generated by stat_bin; documented on the stat_bin
# page

# The reason we might want a "True" histogram is to overlay a density estimate:
ggplot(homes, aes(x=FinSqFt, y=..density..)) + 
  geom_histogram(binwidth=250, color="black", fill="white") +
  geom_density(color="red")
# Notice I "mapped" fixed values to the color and fill aesthetic


# Before we go further, important to note we can save a plot object and add to
# it:
p <- ggplot(homes, aes(x=FinSqFt, y=..density..))
p # nothing to see, no layers
p + geom_histogram(binwidth=300)

# And now try geom_density()
p + geom_density(color="red")

# and combine density and histogram
p + geom_density(color="red") + geom_histogram(alpha=1/3)
# alpha is an aesthetic that defines "transparancy"; range: 0 to 1

# facet by condition:
p + geom_histogram(binwidth=300) + facet_wrap(~ Condition)

# overlayed histograms by condition
ggplot(homes, aes(x=FinSqFt, fill=Condition)) + 
  geom_histogram(position = "identity", alpha=1/3, binwidth=250)
# position="identity" needed for overlapping; without they get stacked

# Try fewer categories
ggplot(subset(homes, Condition %in% c("Excellent","Good","Average")), 
       aes(x=FinSqFt, fill=Condition)) + 
  geom_histogram(position = "identity", alpha=1/3, binwidth=250) 

# Change order in legend using scales function
# The limits argument sets the order
ggplot(subset(homes, Condition %in% c("Excellent","Good","Average")), 
       aes(x=FinSqFt, fill=Condition)) + 
  geom_histogram(position = "identity", alpha=1/3, binwidth=250) +
  scale_fill_discrete(limits=c("Excellent","Good","Average"))

  

####################################
# YOUR TURN! Create a histogram of TotalValue, the total value of the home.
# Try some different bandwidths.


####################################

# Bar Plots help us visualize how discrete values are distributed:
ggplot(homes, aes(x=Condition)) + geom_bar()

# Use a scales function to re-order x-axis
ggplot(homes, aes(x=Condition)) + geom_bar() +
  scale_x_discrete(limits=c("Excellent","Good","Average","Fair","Poor","Substandard"))

# the coord_flip() function allows us to flip the coordinate axis
ggplot(homes, aes(x=Condition)) + geom_bar() +
  scale_x_discrete(limits=c("Excellent","Good","Average","Fair","Poor","Substandard")) +
  coord_flip() 

# Let's map the Remodeled indicator to fill;
# we need to declare Remodeled as a "factor"; stored as numbers: 0 and 1
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + geom_bar()

# Note the "stacked" position. We can change that with the position argument:
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + 
  geom_bar(position = "dodge")

# How can we fix the legend title?
# Recall that is a by-product of the scale. So we need to use a scale function.
ggplot(homes, aes(x=Condition, fill=factor(Remodeled))) + 
  geom_bar(position = "dodge") +
  scale_fill_discrete(name="Remodeled") +
  scale_x_discrete(limits=c("Excellent","Good","Average","Fair","Poor","Substandard"))

# By default, the stat for geom_bar (stat_count) counts up things in your data 
# frame. What if you already have counts? Use stat ="identity" (stat_identity)
# and map value to y aesthetic. Let's make a bar plot for remodeled homes.
remod <- as.data.frame(table(homes$Remodeled))
class(remod)
remod

# without stat="identity" - error 
ggplot(remod, aes(x=Var1, y=Freq)) + geom_bar()

# with stat="identity"
ggplot(remod, aes(x=Var1, y=Freq)) + geom_bar(stat="identity", width=0.5)


# we can fix it up...
ggplot(remod, aes(x=Var1, y=Freq)) + 
  geom_bar(stat="identity", width=0.5) + 
  scale_x_discrete(labels=c("Original","Remodeled")) +
  labs(x=NULL, y="Number of Homes", 
       title="Number of remodeled versus original homes in Charlottesville")

# and it's worth noting the above example was contrived to demonstrate the 
# difference between stat_bin and stat_identity'. We could have used our raw 
# data to create the same plot. Below stat="count" is the default; we don't need
# to include it.
ggplot(homes, aes(x=factor(Remodeled))) + 
  geom_bar(stat="count", width=0.5) +
  scale_x_discrete(labels=c("Original","Remodeled")) +
  labs(x=NULL, y="Number of Homes", 
       title="Number of remodeled versus original homes in Charlottesville")


# Two variables -----------------------------------------------------------

# The scatterplot allows you to visualize the relationship between two
# continuous variables.

# plot FinSqFt vs TotalValue:
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# Lots of overplotting!
# What can we do about that? One solution is the alpha aesthetic. "alpha=1/10"
# means 10 points overplotted adds to a solid color
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(alpha=1/10)

# Can also try smaller points using the shape aesthetic
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(shape=".")

# maybe zoom in? We can do that with coord_cartesian()
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(alpha=1/5) +
  coord_cartesian(xlim=c(0,3000),ylim=c(0,5e5))

# Another approach is to use facets: break the data into subsets 
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  facet_wrap(~ Condition)


# Maybe let the scales vary? 
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  facet_wrap(~ Condition, scales = "free")

# and we can combine our tactics
p3 <- ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + 
  geom_point(alpha=1/6) +
  facet_wrap(~ Condition, scales = "free")
p3

# This example shows that creating usable, interpretable figures takes
# a lot of trial and error!

#################################### 
# YOUR TURN! Plot FinSqFt vs. YearBuilt. Put FinSqFt on the y axis. 
# Facet by Condition. Perhaps try an alpha setting?
ggplot(homes, aes(y=FinSqFt, x=YearBuilt)) + geom_point(alpha=1/6) +
  facet_wrap(~ Condition)


####################################

# Look again at our p3 plot:
p3
# The y-axis scale would look better formatted as dollar amounts. The scales
# package can help with this. It has functions designed for this type of
# situation. When you install ggplot2, scales is installed as well.

# Three functions that are very handy: percent, comma, dollar;
# typically used in a scale function with the labels argument.

library(scales)
p3 <- p3 + 
  scale_y_continuous(labels=dollar) + 
  scale_x_continuous(labels=comma)
p3
# We can add a smooth line through our scatterplots with geom_smooth()
p3 + geom_smooth()
# warning due to Substandard only having 3 obs;
# let's just try fitting a straight linear regression line
p3 + geom_smooth(method="lm")
p3 + geom_smooth(method="lm", se=FALSE)

# we can also specify our own formula; compare a quadratic fit with the 
# nonparametric smooth line
p3 + geom_smooth(se=FALSE, color="red") +
  geom_smooth(method="lm", se=FALSE, formula= y ~ poly(x,2)) 

# The errors are annoying; let's remove the Substandard homes;
# We can replace the data frame using the %+% operator
p3 %+% 
  subset(homes, Condition!="Substandard") + 
  geom_smooth(se=FALSE, color="red") +
  geom_smooth(method="lm", se=FALSE, formula= y ~ poly(x,2)) 


# Log Transformations in scatter plots

# Dollar amounts are often log transformed. It helps "squeeze together" the 
# large values and "spread out" the small values.

# before log transformation:
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point()

# Maybe try log base 10 transformation directly:
ggplot(homes, aes(x=log10(FinSqFt), y=log10(TotalValue))) + geom_point()

# The scale of the axes is on the log10 scale because the data has been
# transformed.

# We can use scale functions to both transform the data and map the scale of the
# axes to the original data.
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point(alpha=1/5) +
  scale_x_log10(labels=comma) + scale_y_log10(labels=dollar)



# Boxplots are good for visualizing a continous variable conditional on a
# discrete variable. Let's look at TotalValue by number of FullBaths:

ggplot(homes, aes(x=FullBath,y=TotalValue)) + geom_boxplot()
# oops. FullBath is not discrete. This works.
p4 <- ggplot(homes, aes(x=factor(FullBath),y=TotalValue))
p4 + geom_boxplot()

p4 + geom_boxplot() + scale_y_continuous(labels=dollar)
# $9,000,000 homes with only two full baths?

p4 + geom_boxplot() + scale_y_continuous(labels=dollar) + 
  facet_wrap(~Condition) + labs(x = "Number of Full Baths")

# Just look at homes under $1,000,000
ggplot(subset(homes, TotalValue < 1e6), 
       aes(x=factor(FullBath),y=TotalValue)) + 
  geom_boxplot() + scale_y_continuous(labels=dollar)

####################################
# YOUR TURN! Make a boxplot of FinSqFt by HalfBath. 
ggplot(homes, aes(x=factor(HalfBath), y=FinSqFt)) + geom_boxplot()



####################################

# A nice alternative to boxplots are stripcharts. Basically plot a 1d 
# scatterplot for each level of the discrete value. Works well for smaller data
# sets.

# 0 bedroom houses (?)
homes0 <- subset(homes, Bedroom==0)

# plot total value per Number of Full Baths
ggplot(homes0, aes(x=factor(FullBath), y=TotalValue)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  scale_y_continuous(labels=dollar)
# position_jitter(w = 0.1, h = 0) means jitter points left-and-right but not
# up-and-down.

# Let's go back to the homes data...

# Plotting two "discrete" integer variables:
# Bedroom vs. FullBath
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_point()

# geom_jitter() can help with this
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_jitter()

# scales could be better...
ggplot(homes, aes(x=Bedroom,y=FullBath)) + geom_jitter(alpha=1/5) +
  scale_x_continuous(breaks=0:16, minor_breaks=NULL) +
  scale_y_continuous(breaks=0:12, minor_breaks=NULL)


# line graphs are nice for connecting dots and showing a trend over time.

# plot number of houses built per year; 
# dnn="YearBuilt" simply names the column containg the years
years <- as.data.frame(table(homes$YearBuilt, dnn="YearBuilt"), 
                           stringsAsFactors = FALSE)
str(years)
# make YearBuilt numeric
years$YearBuilt <- as.numeric(years$YearBuilt)

# now use geom_line()
ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line()

# again we can touch up the scales and labels
ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line() +
  scale_x_continuous(breaks=seq(1700,2000,50)) +
  labs(x="Year",y="Number of Homes")

# what year was the spike?
subset(years, Freq > 800)

# we can add the year to the plot using annotate()
ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line() +
  scale_x_continuous(breaks=seq(1700,2000,50)) +
  labs(x="Year",y="Number of Homes") +
  annotate("text", x = 1985, y = 800, label = "1973") 

# We can also add the year to the plot using geom_text:
ggplot(years, aes(x=YearBuilt, y=Freq)) + geom_line() +
  scale_x_continuous(breaks=seq(1700,2000,50)) +
  labs(x="Year",y="Number of Homes") +
  geom_text(data = NULL, x = 1985, y = 800, label = "1973")
# why data = NULL? Tell geom_text not to use the data defined in ggplot().
# You can define data and aesthetics in geoms!

# Quick demo
dat <- data.frame(a = 1:4, b = 2:5)
dat2 <- data.frame(c = 5:2, d = 5:2)
dat; dat2
# plot with dat
ggplot(dat, aes(x = a, y = b)) + 
  geom_point() 
# plot with dat and dat2
ggplot(dat, aes(x = a, y = b)) + 
  geom_point() +
  geom_line(data=dat2, aes(x = c, y = d))


# Plotting statistical summaries ------------------------------------------

# the stat_summary() function is useful for summarizing y values for unique x 
# values. The basic usage is to supply a function to the fun.y argument.

# Let's say I want to plot the mean TotalValue per YearBuilt:
ggplot(homes, aes(x=YearBuilt, y=TotalValue)) +
  stat_summary(fun.y="mean", colour="red", geom="point")

# we could also do it over a scatter plot of TotalValue vs YearBuilt
ggplot(homes, aes(x=YearBuilt, y=TotalValue)) + 
  geom_point() +
  stat_summary(fun.y="mean", colour="red", geom="point")

# zoom in on 1950 - 2015
ggplot(homes, aes(x=YearBuilt, y=TotalValue)) + 
  geom_point(shape=".") +
  stat_summary(fun.y="mean", colour="red", geom="point") +
  coord_cartesian(xlim=c(1950,2016), ylim=c(0,1e6))
# worth noting we're just zooming; the mean still calculated using values
# outside of view.

# let's jitter the points and make summery point bigger
ggplot(homes, aes(x=YearBuilt, y=TotalValue)) + 
  geom_point(position=position_jitter(w=0.2,h=0), shape=".") +
  stat_summary(fun.y="mean", colour="red", geom="point", size=3) +
  coord_cartesian(xlim=c(1950,2016), ylim=c(0,1e6))

# we can add the median 
ggplot(homes, aes(x=YearBuilt, y=TotalValue)) + 
  geom_point(position=position_jitter(w=0.2,h=0), shape=".") +
  stat_summary(fun.y="mean", colour="red", geom="line") +
  stat_summary(fun.y="median", colour="blue", geom="line") +
  coord_cartesian(xlim=c(1950,2016), ylim=c(0,1e6))

# FullBaths vs YearBuilt
ggplot(homes, aes(x=YearBuilt, y=FullBath)) + geom_point()

# add some jitter, transparancy and zoom in
ggplot(homes, aes(x=YearBuilt, y=FullBath)) + 
  geom_jitter(alpha=1/8) +
  coord_cartesian(xlim=c(1950,2016))

# now add some stats
ggplot(homes, aes(x=YearBuilt, y=FullBath)) + 
  geom_jitter(alpha=1/8) +
  coord_cartesian(xlim=c(1950,2016), ylim=c(0,6)) +
  stat_summary(fun.y="mean", color="red", geom="line", size=2) +
  scale_y_continuous(breaks=0:6) +
  scale_x_continuous(breaks=seq(1960,2010,10))


# can also add summary stats manually
# first calculate the summary stats and put in data frame
avHome <- data.frame(x=median(homes$FinSqFt),
                     y=median(homes$TotalValue))
avHome # the average home

# make scatterplot and add summary stat
ggplot(homes, aes(x=FinSqFt, y=TotalValue)) + geom_point() +
  geom_point(data=avHome, aes(x=x,y=y), color="red", size=4)


# Multiple plots in one window --------------------------------------------


# In base R, we usually use par(mfrow=c(i,j)), like so:
par(mfrow=c(1,2))
hist(homes$FinSqFt)
plot(FinSqFt ~ YearBuilt, data=homes)
par(mfrow=c(1,1))

# We cannot use this approach for ggplot2. The easiest solution is to use the 
# grid.arrange() function in the gridExtra package. To use it, you have to save
# your plots and then call them using grid.arrange().

p1 <- ggplot(homes, aes(x=FinSqFt)) + geom_histogram() 
p2 <- ggplot(homes, aes(x=YearBuilt, y=FinSqFt)) + geom_point()
library(gridExtra)
grid.arrange(p1, p2, nrow=1) # can also use ncol



# Time-Permitting Miscellaneous Topics ------------------------------------


# adding uncertainty to graphs 

# Example: add means and CIs to strip chart 
# Data: chickwts (An experiment was conducted to measure and compare the
# effectiveness of various feed supplements on the growth rate of chickens.)
str(chickwts)

sc <- ggplot(chickwts, aes(x=feed, y=weight)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0))
sc

# now to calculate means and standard errors
fMean <- tapply(chickwts$weight, chickwts$feed, mean)
fSE <- tapply(chickwts$weight, chickwts$feed, function(x) sd(x)/sqrt(length(x)))
chick2 <- data.frame(feed=names(fMean), fMean, fSE, row.names = NULL)

# now add mean and error bars
sc + geom_point(data=chick2, aes(x=feed, y=fMean), color="red", size=3) +
  geom_errorbar(data=chick2, aes(x=feed, y=fMean,
                                 ymin=fMean - 2*fSE, 
                                 ymax=fMean + 2*fSE), 
                width=0.1, color="red") +
  labs(title="Mean Weight by Feed Type with 2*SE error bars")

# another way using stat_summary; fun.data="mean_cl_normal" actually calls the 
# function smean.cl.normal() from the Hmisc package. It uses the t distribution
# to determine the multiplier of the standard error.
ggplot(chickwts, aes(x=feed, y=weight)) + 
  geom_point(position = position_jitter(w = 0.1, h = 0)) +
  stat_summary(fun.data = "mean_cl_normal", color="red", geom="errorbar", width=0.1) +
  stat_summary(fun.y = "mean", geom="point", color="red", size=3) +
  labs(title="Mean Weight by Feed Type with 95% error bars")



# single line graph of means at each time point with SE bars

# Indometh data (comes with R)
# Six subjects were given an intravenous injection of indometacin at 11 times,
# and each time plasma concentrations of indometacin was measured.
# Need the Hmisc package
library(Hmisc)

# Here we make a line plot for each subject:
ggplot(Indometh, aes(x=time,y=conc, group=Subject)) +
  geom_line()

# Let's say we wanted to create a single line graph of means at each time point
# with SE bars.

# first calculate means and SEs
tMean <- tapply(Indometh$conc, Indometh$time, mean)
tSE <- tapply(Indometh$conc, Indometh$time, function(x)sd(x)/sqrt(length(x)))

# ggplot requires data in data frame
Indo2 <- data.frame(time=unique(Indometh$time), tMean, tSE, row.names = NULL)
Indo2

# now ready to create plot
ggplot(Indo2, aes(x=time,y=tMean)) +
  geom_line() +
  geom_errorbar(aes(ymin=tMean-2*tSE, ymax=tMean+2*tSE), width=0.1)

# or again we can use stat_summary()
ggplot(Indometh, aes(x=time,y=conc)) +
  stat_summary(fun.data="mean_cl_normal", geom="errorbar", width=0.1) +
  stat_summary(fun.y = mean, geom="line")


# maps
# ggplot can plot maps

# The following data are occurences of cougars in the US. It was downloaded from
# Biodiversity Information Serving Our Nation (BISON),
# http://bison.usgs.ornl.gov.

url <- "http://people.virginia.edu/~jcf2d/workshops/ggplot2/bison-Cougar-20150520-172801.csv"
cougar <- read.csv(url)

# install.packages("maps")
# install.packages("mapproj")

library(maps)
library(mapproj) # for the "polyconic" option

# Let's plot a map that shows occurences of courgars in the US and the type of occurence.

# first create a data frame of map data; "state" is the name of a map provided
# by the maps package.
states <- map_data("state")
# rename providedState to "region" and make lower case for purposes of merging
cougar$region <- tolower(cougar$providedState)
# merge states and courgar data frames by region
cougmap <- merge(states, subset(cougar, !is.na(decimalLongitude)), by = "region")

# now we're ready to plot! Map longitude and latitude to x and y aesthetics;
# The borders function draws the state borders;
# the coord_map("polyconic") function makes the map look curvy, like a globe;
# Give it a second...
ggplot(cougmap, aes(x=long, y=lat)) +
  borders("state") +
  geom_point(aes(x = decimalLongitude, y=decimalLatitude, color=basisOfRecord)) +
  coord_map("polyconic")

# saving graphs as images

# use ggsave(). It saves the last plot according to your file extension.
ggsave("cougars.jpg", width=10, height=5)


# Themes

# Using built-in themes such as theme_bw()
# Before
ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month)
# After
ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month) + theme_bw()
# another: theme_light
ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month) + theme_light()

# To permanently change the theme:
prevTheme <- theme_set(theme_bw())

ggplot(airquality, aes(x=Temp)) + geom_histogram(binwidth=2) +
  facet_wrap(~Month)

ggplot(airquality, aes(x=Temp)) + geom_freqpoly(binwidth=2) +
  facet_wrap(~Month)

# To restore
theme_set(prevTheme)
# verify
ggplot(airquality, aes(x=Temp)) + geom_freqpoly(binwidth=2) +
  facet_wrap(~Month)

