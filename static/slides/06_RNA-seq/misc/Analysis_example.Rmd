---
output:
  html_document:
    theme: united
    toc: yes
# date: "`r Sys.Date()`"
# author: "Mikhail Dozmorov"
# runtime: shiny
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
# Set up the environment
library(knitr)
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=F, tidy=T, fig.keep='high', echo=F, dpi=100, warnings=F, message=F, comment=NA, warning=F, results='as.is') #out.width=700, 
library(pander)
panderOptions('table.split.table', Inf)
set.seed(1)
library(dplyr)
options(stringsAsFactors = FALSE)
```

```{r libraries}
library(openxlsx)
library(DT)
library(edgeR)
library(sva)
library(ggplot2)
library(ggrepel)
library(reshape2)
library(plotly)
library(dplyr)
library(reshape2)
library(MDmisc)
library(heatmaply)
library(org.Mm.eg.db)
library(shiny)
library(ggplot2)
library(pheatmap)
library(annotables) # Annotations of Ensembl IDs
# Remove non-canonical chromosome names
grcm38 <- grcm38[ !(grepl("_", grcm38$chr) | grepl("GL", grcm38$chr)), c("ensgene", "symbol", "description")]
grcm38 <- grcm38[ !duplicated(grcm38) & !is.na(grcm38$symbol) & grcm38$description != "", ]
all.symbol <- unique(grcm38$symbol) # All genes for background
```

# Settings

```{r}
p.adj <- 0.1
fdr.cutoff <- 0.3
top_n <- 50
```


# QC

Quality control was performed on each processing stage. The final QC metrics for the aligned BAM files are shown.

```{r}
qc_counts <- read.table("data/03_featureCounts/counts.txt.summary", sep = "\t", header = TRUE)
colnames(qc_counts) <- sub("03_sorted.", "", colnames(qc_counts))
colnames(qc_counts) <- sub("_L003_R1_001_paired.fastq.gz.bam", "", colnames(qc_counts))
```


```{r}
p <- ggplot(data = melt(qc_counts), aes(x = variable, y = value)) +
  geom_bar(stat = "identity", aes(fill = Status)) + 
  guides(fill=FALSE) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
ggplotly(p)
```

**Summary:** Good and relatively uniformly mapped data

# Load data

```{r }
# Combined matrix
count.matrix <- read.table("data/03_featureCounts/counts.txt.gz", sep = "\t", header = TRUE)

# Separate genes and counts
genes <- count.matrix[ , grepl("Geneid|Length", colnames(count.matrix))] # Keep columns with annotations
# Keep counts, and adjust column names
counts <- count.matrix[ , grepl("bam", colnames(count.matrix))] %>% as.matrix # Keep columns with counts
colnames(counts) <- sub("X03_sorted.", "", colnames(counts)) # Remove column prefix
colnames(counts) <- sub("_L003_R1_001_paired.fastq.gz.bam", "", colnames(counts))

# Filter out low expressed genes
# Should be more than 100% of non-zero values
# ff <- genefilter::pOverA(p = 1.0, A = 0, na.rm = TRUE) 
# index <- apply(counts, 1, ff) # Index of rows having non-zero counts
# counts <- counts[index, ]
# genes <- genes[index, ]
# genes$Length <- as.integer(genes$Length)

sample_annotation <- read.csv("data/sample_annotation.csv")
all.equal(colnames(counts), sample_annotation$ID)
```

```{r}
Group <- factor(sample_annotation$Group)
Group <- relevel(Group, ref = "A")
Group
design <- model.matrix(~Group, data = Group)
```


```{r}
edgeR.dgelist = DGEList(counts = counts[, ], genes = genes)
# Filtering
keep <- rowSums(cpm(edgeR.dgelist)>1) >= 2
edgeR.dgelist <- edgeR.dgelist[keep, , keep.lib.sizes=FALSE]
# Normalization
edgeR.dgelist = calcNormFactors((edgeR.dgelist), method = "TMM")
edgeR.dgelist = estimateDisp(edgeR.dgelist, design)
```

```{r}
# Get normalized CPMs
mtx <- cpm(edgeR.dgelist, log = TRUE, normalized.lib.sizes = TRUE)
mtx_to_plot <- varFilter(mtx, var.cutoff = 0.75)
```

```{r eval = FALSE}
grch38 <- grch38[ !(grepl("_", grch38$chr) | grepl("GL", grch38$chr)), c("ensgene", "symbol")]
grch38 <- grch38[ !duplicated(grch38) & !is.na(grch38$symbol), ]
# Save objects for shiny app
barplot.data <- edgeR.dgelist@.Data[[3]]
barplot.data$Geneid <- sapply(barplot.data$Geneid, function(x) strsplit(x, ".", fixed = TRUE)[[1]][1])
barplot.data <- left_join(barplot.data, grch38, by = c("Geneid" = "ensgene"))
barplot.data <- barplot.data[, c("Geneid", "symbol")]
colnames(barplot.data) <- c("Geneid", "Symbol")
barplot.data <- cbind(barplot.data, cpm(edgeR.dgelist, log = TRUE, normalized.lib.sizes = TRUE))

annotations <- sample_annotation
colnames(annotations) <- c("ID", "Differentiation", "Scrambled", "Knockout", "allgroups")
save(list = c("barplot.data", "annotations"), file = "barplot.data.rda")
```


# Correlation matrix

```{r}
IAC <- mtx_to_plot %>% cor(. , use = "pairwise.complete.obs",  method = "pearson")
heatmaply(IAC) %>% layout(margin = list(l = 200, b = 150))

```

# Dendrogram

```{r}
plot(hclust(as.dist(1 - IAC), method = "ward"))
```

# Principal Components Analysis

```{r}
# PCA: Check for batch effects. Select one batch, to color points by its assignment
pca <-  mtx_to_plot %>% scale %>% t %>% prcomp
data.frame(summary(pca)$importance)[, 1:5] %>% pander # Percent of variance explained

# # What correlates with the first component
# covariates <- c("Sample_Plate", "Sentrix_ID", "Sentrix_Position", "Sample_Well", "Type", "Donor", "Injury", "Predicted.Gender")
# for (covariate in covariates){
#   pca.lm <- lm( as.numeric(PC1) ~ factor(eval(parse(text = covariate))), data = cbind(sample_annotation, pca$x))
#   print(paste(covariate, "accounts for", signif(summary(pca.lm)$adj.r.squared, 5), "variability explained by PC1, p-value", signif(lmp(pca.lm), 5)))
#   # pca.lm <- lm( as.numeric(PC2) ~ factor(eval(parse(text = covariate))), data = cbind(sample_annotation, pca$x))
#   # print(paste(covariate, "accounts for", signif(summary(pca.lm)$adj.r.squared, 5), "variability explained by the second principle component, # p-value", signif(lmp(pca.lm), 5)))
#   # pca.lm <- lm( as.numeric(PC3) ~ factor(eval(parse(text = covariate))), data = cbind(sample_annotation, pca$x))
#   # print(paste(covariate, "accounts for", signif(summary(pca.lm)$adj.r.squared, 5), "variability explained by the third principle component, # p-value", signif(lmp(pca.lm), 5)))
# }

colorby <- "Group" # covariates[2]
pt <- ggplot(data = data.frame(pca$x, sample_annotation, samples = sample_annotation$ID, stringsAsFactors = F), 
             aes(x = as.numeric(PC1), y = as.numeric(PC2), label = samples)) +
  theme(plot.title = element_text(lineheight = 0.8, face="bold")) +
  ggtitle(paste("PCA with batch, coloring by ", colorby)) +
  geom_point(aes(color = eval(parse(text = colorby))), size = 3) +
  geom_text_repel(colour = "black", size = 3) +
  geom_hline(yintercept = 0, colour = "gray65") +
  geom_vline(xintercept = 0, colour = "gray65") +
  labs(color = colorby) +
  scale_x_continuous(name = paste0("PC1, ", round(summary(pca)$importance[2,1] * 100, digits = 2), "% variability" )) +
  scale_y_continuous(name = paste0("PC2, ", round(summary(pca)$importance[2,2] * 100, digits = 2), "% variability" ))
plot(pt)

# ggsave(filename = "Figures/Figure_PCA_withbatch.pdf", plot = pt, height = 8, width = 11)
```

# Helper functions

```{r}
# A wrapper function to perform all functional enrichment analyses.
# Helper function to save non-empty results
save_res <- function(res, fileName = fileName, wb = wb, sheetName = "KEGG") {
  if (nrow(res) > 0) {
    openxlsx::addWorksheet(wb = wb, sheetName = sheetName)
    openxlsx::writeData(wb, res, sheet = sheetName)
    openxlsx::saveWorkbook(wb, fileName, overwrite = TRUE)
  }
}

# Function to compare groups
#' @param object glmLTR result
#' @param p.adj FDR adjusted p-value cutoff
#' @param subset_by logical vectore defined earlier and used to subset the whole dataset
#' @param comparison text defining what comparison has been made
#' @param nplot how many top differential genes to plot
p.vals <- function(object, p.adj = 0.1, subset_by = subset_by, comparison = "DEGs", nplot = 50, print_to_file = TRUE) {
  genes.ABC <- topTags(object, n = Inf, p.value = p.adj) %>% as.data.frame # Get all significant genes
  
  genes.ABC$ensgene <- sapply(genes.ABC$Geneid, function(x) strsplit(x, ".", fixed = TRUE)[[1]][1])
  genes.ABC <- left_join(data.frame(genes.ABC, stringsAsFactors = FALSE), grch38, by = c("ensgene" = "ensgene")) # Attach annotations
  
  if (print_to_file) {
    # Save most significant genes
    save_res(genes.ABC, fileName, wb = wb, sheetName = comparison) # Save gene list
  }
  # Return actual gene list
  return(genes.ABC)
}

# Function to plot and save selected gene lists
genes_to_heatmap <- function(object, edgeR.dgelist = edgeR.dgelist, nplot = 50, subset_by = c("A", "B"), comparison = "C231_noCRISPR_vs_Negative", clustmethod = "ward", width = 6, height = 8, print_to_file = TRUE) {
  # Select columns to subset
  if (!is.na(subset_by)){
    subset_index <- grepl(paste(subset_by, collapse = "|"), sample_annotation$Group) 
  } else {
    subset_index <- 1:ncol(cpm(edgeR.dgelist, log = TRUE))
  }
  # # Order object by the most on-average significant genes
  # object <- object[ order( (rank(object$FDR.x) + rank(object$FDR.y)) / 2), ] 
  # # Save most significant genes
  # fileName <- paste0("results/DEGs_", comparison,  "_hg19.xlsx") # Construct filename
  # unlink(fileName) # Delete file, if exists
  # write.xlsx2(object, fileName, sheetName = comparison, row.names = FALSE) # Save gene list
  
  # Plot top genes
  genes.to.plot <- object[1:nplot, c("Geneid", "symbol")] 
  genes.to.plot <- genes.to.plot[match(edgeR.dgelist@.Data[[3]]$Geneid[edgeR.dgelist@.Data[[3]]$Geneid %in% genes.to.plot$Geneid], genes.to.plot$Geneid), ] # Make the same order as the genes subsetted from the whole dataset
  matrix.to.plot <- cpm(edgeR.dgelist, log = TRUE, normalized.lib.sizes=TRUE)[edgeR.dgelist@.Data[[3]]$Geneid %in% genes.to.plot$Geneid, subset_index] # * edgeR.dgelist@.Data[[2]]$norm.factors[subset_index] # Subset matrix to plot
  
  annotation_col <- data.frame(Group = sample_annotation$Group[subset_index])
  rownames(annotation_col) <- colnames(cpm(edgeR.dgelist)[, subset_index])
  
  # Save to PDF
  if (print_to_file) {
    pdf(paste0("results/Figure_Heatmap_", comparison, "_", nplot, ".pdf"), width = width, height = height)
    NMF::aheatmap(matrix.to.plot, color=colorRampPalette(c('blue', 'gray', 'yellow'))(20), hclust = clustmethod, scale = "row", annCol = apply(data.frame(annotation_samples$Cell[ subset_index ], annotation_samples$Condition[ subset_index ]), 1, paste, collapse = "_"), annColors = list(c("red", "blue")), labRow = genes.to.plot$symbol, fontsize = 10, cexRow = 10) # color="-RdYlBu"
    dev.off()
  } else {
    # NMF::aheatmap(matrix.to.plot, color=colorRampPalette(c('blue', 'gray', 'yellow'))(20), hclust = clustmethod, scale = "row", annCol = sample_annotation$Group[subset_index], annColors = list(c("red", "blue")), labRow = genes.to.plot$symbol, fontsize = 10, cexRow = 10) # color="-RdYlBu"
    pheatmap(matrix.to.plot, color=colorRampPalette(c('blue', 'white', 'red'))(20), clustering_method = "ward", treeheight_row = FALSE, treeheight_col = FALSE, annotation_col = annotation_col, labels_row = genes.to.plot$symbol)

  }
}
```

# Comparison

Differentially espressed genes (DEGs) detected at False Discovery Rate (FDR) `r p.adj`. See the total number in the table' annotations. Top `r top_n` or less DEGs are visualized.

Legend for gene lists: "Geneid", "symbol", "description" - gene annotations; "Length" - length of a gene in bp; "logFC" - log fold change; "logCPM" - average Counts Per Million, log2; "LR" - log-likelyhood; "P.Val"/"adj.P.Val" - non-/FDR-adjusted p-value.

## DEGs_1: Compare the scramble control without erythroid differentiation to the knockout without erythroid differentiation

```{r}
# Save differentially expressed genes
fileName <- "results/DEGs_1.xlsx"
unlink(fileName)
# Create (or, load)  Excel file
wb <- openxlsx::createWorkbook(fileName)
```


```{r}
# One-way ANOVA analysis
fit <- glmFit(edgeR.dgelist, design)
# Individual comparisons
lrt <- glmLRT(fit, coef = 2)
res <- p.vals(object = lrt, p.adj = 1, comparison = "DEGs_1", print_to_file = TRUE)
res <- p.vals(object = lrt, p.adj = p.adj, comparison = "DEGs_1", print_to_file = FALSE)
res$logFC <- signif(res$logFC)
res$logCPM <- signif(res$logCPM)
res$LR <- signif(res$LR)
res$PValue <- formatC(res$PValue, digits = 3, format = "e")
res$FDR <- formatC(res$FDR, digits = 3, format = "e")
datatable(res)
```

```{r fig.height=12}
genes_to_heatmap(object = res, edgeR.dgelist = edgeR.dgelist, subset_by = c("A", "B"), nplot = top_n, comparison = "DEGs_1", clustmethod = "ward", width = 6, height = 8, print_to_file = FALSE)
```

## DEGs_2: Compare the scramble control with erythroid differentiation with the knockout with with erythroid differentiation

```{r}
# Save differentially expressed genes
fileName <- "results/DEGs_2.xlsx"
unlink(fileName)
# Create (or, load)  Excel file
wb <- openxlsx::createWorkbook(fileName)
```


```{r}
# One-way ANOVA analysis
fit <- glmFit(edgeR.dgelist, design)
# Individual comparisons
lrt <- glmLRT(fit, contrast = c(0, 0, -1, 1))
res <- p.vals(object = lrt, p.adj = 1, comparison = "DEGs_2", print_to_file = TRUE)
res <- p.vals(object = lrt, p.adj = p.adj, comparison = "DEGs_2", print_to_file = FALSE)
res$logFC <- signif(res$logFC)
res$logCPM <- signif(res$logCPM)
res$LR <- signif(res$LR)
res$PValue <- formatC(res$PValue, digits = 3, format = "e")
res$FDR <- formatC(res$FDR, digits = 3, format = "e")
datatable(res)
```

```{r fig.height=12}
genes_to_heatmap(object = res, edgeR.dgelist = edgeR.dgelist, subset_by = c("C", "D"), nplot = top_n, comparison = "DEGs_2", clustmethod = "ward", width = 6, height = 8, print_to_file = FALSE)
```

# Functional enrichment analysis

- Up- and downregulated genes are tested for enrichment separately. Only genes at FDR < `r p.adj` are analyzed.

- Each table has enrichment results for up/downregulated genes. The "direction" column indicate which pathways are enriched in "UP"- or "DN"-regulated genes.

- Use the "Search" box for each table, to filter the results for "UP" or "DN" only. Search is global within the table, case insensitive.

- FDR cutoff of the significant enrichments - `r fdr.cutoff`.

Legend: "database" - source of functional annotations, "category" - name of functional annotation,  "pval" - unadjusted enrichment p-value,  "qval" - FDR-adjusted p-value,  "genes" - comma-separated differentially expressed genes enriched in a corresponding functional category,  "direction" - UP/DN, an indicator whether genes are up- or downregulated.
